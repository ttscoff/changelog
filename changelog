#!/usr/bin/ruby -W1
# frozen_string_literal: true

require 'optparse'
require 'shellwords'
require 'yaml'

VERSION = '1.0.0'

# A script to automate changelog generation from Git commit messages
#
# For use with a git-flow workflow, it will take changes from the last tagged
# release where commit messages contain NEW, FIXED, CHANGED, and IMPROVED
# keywords and sort and format them into a Markdown release note list.
#
# The script takes version information from a version.rb files, the macOS
# command agvtool (bases the product name on the first matching Xcode Info.plist
# found) or from a plain text VERSION file.
#
# Format commit messages with markers
#
# Commit message
# - NEW: New feature description
# - FIXED: Fix description
#
# OR with @format:
#
# Commit message
# @new New feature
# @changed application feature change
# @breaking breaking change
#
# Single-line commit messages formatted like a line from the notes above will
# also be recognized.

# Constant CL_STRINGS: Strings for section titles and keywords
# :title is what is displayed in output
# :rx is the regex search to match each type, case sensitive
CL_STRINGS = {
  changed: { title: 'CHANGED', rx: '(CHANGED?|BREAK(ING)?)' },
  new: { title: 'NEW', rx: '(NEW|ADD(ED)?)' },
  improved: { title: 'IMPROVED', rx: '(IMP(ROV(MENT|ED)?)?|UPD(ATED?)?)' },
  fixed: { title: 'FIXED', rx: 'FIX(ED)?' },
  deprecated: { title: 'REMOVED', rx: '(DEP(RECATED)?|REM(OVED?)?)' }
}.freeze

##
## @brief      String helpers
##
class ::String
  # Destructive version of #cap_first
  def cap_first!
    replace cap_first
  end

  # Capitalize first letter
  def cap_first
    sub(/^([a-z])(.*)$/) do
      m = Regexp.last_match
      m[1].upcase << m[2]
    end
  end

  # Remove marker strings like @fix and "- NEW:"
  #
  # @return [String] cleaned string
  #
  def clean_entry
    rx = CL_STRINGS.map do |_, v|
      "(?:@#{v[:rx].downcase}|#{v[:rx]}:)"
    end

    rx = format('(?:%<rx>s)', rx: rx.join('|'))

    sub(/^(?:[-*+] )*#{rx} *(: )?/, '').cap_first
  end

  def remove_accents
    diacritics = [*0x1DC0..0x1DFF, *0x0300..0x036F, *0xFE20..0xFE2F].pack('U*')
    unicode_normalize(:nfd)
      .tr(diacritics, '')
      .unicode_normalize(:nfc)
  end

  def strip_non_ascii
    force_encoding('utf-8').gsub(/[^[:ascii:]]/) do |non_ascii|
      non_ascii.force_encoding('utf-8')
               .encode('utf-16be')
               .unpack('H*').join
               .gsub(/(....)/, '')
    end
  end
end

##
## @brief      Changelog Item
##
class Change < Hash
  attr_accessor :githash, :date, :changes

  def initialize(githash, date, changes)
    @githash = githash
    @date = date
    @changes = changes
    super()
  end
end

##
## @brief      Changelog Set
##
class ChangeSet
  attr_accessor :changed, :new, :improved, :fixed

  def initialize
    @changed = []
    @new = []
    @improved = []
    @fixed = []
  end

  def add(type, change)
    case type
    when :changed
      @changed.push change
    when :new
      @new.push change
    when :improved
      @improved.push change
    when :fixed
      @fixed.push change
    end
  end

  def get(type)
    case type
    when :changed
      return @changed
    when :new
      return @new
    when :improved
      return @improved
    when :fixed
      return @fixed
    end
    nil
  end
end

# Array of changes
class ChangeLog < Array
  def initialize(*change_array)
    super(change_array)
  end

  # returns array of :changes values
  def changes
    res = []
    each do |v|
      chgs = v.changes.strip.split(/\n/)
      chgs.delete_if { |e| e.strip.empty? }
      res.concat(chgs)
    end
    res.uniq
  end

  def changes!
    replace changes
  end
end

# Main class
class ChangeLogger
  attr_reader :changes, :version, :version_changes

  def initialize(app_title = nil, options: {})
    @options = options
    # Ensure order always has a value
    @options[:order] ||= :desc
    @changes = ChangeSet.new
    @version_changes = {} # Hash of version => ChangeSet for split output
    # Cache revision result to avoid multiple fzf prompts when using --select
    @options[:_cached_revision] ||= ChangeLogger.revision(@options)
    revision_lambda = -> { @options[:_cached_revision] }
    gen_rx_lambda = -> { GitLogParser.gen_rx }
    @log = GitLogParser.gitlog(@options, revision_lambda, gen_rx_lambda)
    @app_title = app_title || nil
    if @options[:split]
      GitLogParser.sort_changes_by_version(self)
    else
      GitLogParser.sort_changes(self)
    end
  end

  def to_s
    return split_output if @options[:split] && !@version_changes.empty?

    # Ensure version/app title are detected and cached for this instance
    fmt_for_detection = @options[:format] || :markdown
    version_info = VersionDetector.detect(@options, @version, @app_title, fmt_for_detection)
    @version = version_info[:version]
    @app_title = version_info[:app_name]

    # Use the precomputed header_out for the primary format, and fall back to dynamic
    # header generation for any other format (e.g. split output or reuse).
    header_lambda = lambda do |fmt|
      if fmt == fmt_for_detection
        version_info[:header_out]
      else
        ChangelogFormatter.header(fmt, @options, @version, @app_title)
      end
    end

    ChangelogFormatter.format(@changes, @options, header_lambda, @version)
  end

  # Generate output split by version
  def split_output
    types = CL_STRINGS.select { |k, _v| @options[:types].include?(k) }
    output = ''
    versions = @version_changes.keys
    versions = versions.reverse if @options[:order] == :desc
    versions.each do |version|
      changeset = @version_changes[version]
      case @options[:format]
      when :keepachangelog
        output += "## [#{version}] - #{Time.now.strftime('%F')}\n\n"
        types.each_key do |k|
          changes = changeset.get(k)
          next if changes.empty?

          output += "### #{CL_STRINGS[k][:title].capitalize}\n\n"
          output += "- #{changes.join("\n- ")}\n\n"
        end
      when :def_list
        output += "#{version}\n"
        types.each_key do |k|
          changes = changeset.get(k)
          changes.each { |item| output += ": #{item}\n" }
        end
        output += "\n"
      else
        output += "### #{version}\n\n"
        types.each_key do |k|
          changes = changeset.get(k)
          next if changes.empty?

          output += "#### #{CL_STRINGS[k][:title]}\n\n"
          output += "- #{changes.join("\n- ")}\n\n"
        end
      end
    end
    output
  end

  # Adds or updates the footer link for a version in Keep a Changelog format
  # Detects existing link pattern and generates matching link for new version
  #
  # @param content [String] The changelog content
  # @param version [String] The version to add a link for
  # @return [String] The updated content with the new link
  def add_keepachangelog_link(content, version)
    # Look for existing footer links like [0.1.0]: https://github.com/user/repo/releases/tag/v0.1.0
    if content =~ %r{^\[(\d+\.\d+\.\d+)\]: *(https://github\.com/[^/]+/[^/]+/releases/tag/v?)([\d.]+) *$}m
      base_url = content.match(%r{^\[\d+\.\d+\.\d+\]: *(https://github\.com/[^/]+/[^/]+/releases/tag/v?)[\d.]+ *$}m)[1]
      version_rx = version.gsub(/\./, '\.')

      # Check if link already exists for this version
      unless content =~ /^\[#{version_rx}\]:/m
        # Find the first link line and insert before it
        new_link = "[#{version}]: #{base_url}#{version}"
        content.sub!(/^(\[\d+\.\d+\.\d+\]:)/m, "#{new_link}\n\\1")
      end
    end

    content
  end

  # Static version for use in to_s
  def self.add_keepachangelog_link_static(content, version)
    return content unless version && content =~ /## \[#{Regexp.escape(version)}\]/

    # Look for existing footer links like [0.1.0]: https://github.com/user/repo/releases/tag/v0.1.0
    if content =~ %r{^\[(\d+\.\d+\.\d+)\]: *(https://github\.com/[^/]+/[^/]+/releases/tag/v?)([\d.]+) *$}m
      base_url = content.match(%r{^\[\d+\.\d+\.\d+\]: *(https://github\.com/[^/]+/[^/]+/releases/tag/v?)[\d.]+ *$}m)[1]
      version_rx = version.gsub(/\./, '\\.')
      unless content =~ /^\[#{version_rx}\]:/m
        # Find the first link line and insert before it
        new_link = "[#{version}]: #{base_url}#{version}"
        content.sub!(/^(\[\d+\.\d+\.\d+\]:)/m, "#{new_link}\n\\1")
      end
    else
      # If no links exist, append a new one at the end
      repo_url = `git config --get remote.origin.url`.strip
      if repo_url =~ %r{github.com[:/](.+)/(.+?)(\.git)?$}
        user_repo = "#{::Regexp.last_match(1)}/#{::Regexp.last_match(2)}"
        new_link = "[#{version}]: https://github.com/#{user_repo}/releases/tag/v#{version}"
        content = "#{content.rstrip}\n\n#{new_link}\n"
      end
    end
    content
  end

  # Move revision to a class method for lambda use
  def self.revision(options)
    if options[:since_version]
      tags = `git tag -l`.split("\n")
      matches = tags.select { |tag| tag.include?(options[:since_version]) }
      if matches.empty?
        warn "No matching tag found for '#{options[:since_version]}'"
        Process.exit 1
      elsif matches.size == 1 || !$stdin.tty?
        selected_tag = matches.first
      else
        fzf_input = matches.join("\n")
        selected_tag = `echo #{Shellwords.escape(fzf_input)} | fzf --tac`.strip
        if selected_tag.empty?
          warn 'No selection made'
          Process.exit 1
        end
      end
      `git log -1 --format=format:"%H" #{selected_tag}`
    elsif options[:select]
      tags = `git tag -n0 -l`.strip
      selection = `echo #{Shellwords.escape(tags)}  | fzf --tac`.strip
      raise 'No selection' if selection.empty?

      `git log -1 --format=format:"%H" #{selection}`
    else
      `git rev-list --tags --max-count=1`
    end
  end
end

# Formatter module
module ChangelogFormatter
  def self.format(changes, options, header_method, version)
    types = CL_STRINGS.select { |k, _v| options[:types].include?(k) }
    case options[:format]
    when :def_list
      output = []
      res = {}
      types.each_key { |k| res[k] = changes.get(k) }
      res.each_value { |v| v.each { |item| output.push(": #{item}") } }
      "#{header_method.call(:def_list)}#{output.join("\n")}"
    when :bunch
      output = []
      res = {}
      types.each_key { |k| res[k] = changes.get(k) }
      res.each do |k, v|
        icon = case k.downcase
               when /^fix/
                 'fix'
               when /^(cha|imp)/
                 'imp'
               when /^new/
                 'new'
               end
        v.each do |item|
          item.gsub!(%r{https://bunchapp.co}, '{{ site.baseurl }}')
          ico = "{% icon #{icon} %}"
          ico += '{% icon breaking %}' if item =~ /BREAKING/
          output.push(": #{ico} #{item}")
        end
      end
      "#{header_method.call(:bunch)}\n#{output.join("\n")}\n\n{% endavailable %}"
    when :keepachangelog
      output = ''
      res = {}
      types.each_key { |k| res[k] = changes.get(k) }
      res.each do |k, v|
        next if v.empty?

        output += "### #{CL_STRINGS[k][:title].capitalize}\n\n"
        output += "- #{v.join("\n- ")}\n\n"
      end
      out = header_method.call(:keepachangelog) + output
      ChangeLogger.add_keepachangelog_link_static(out, version)
    else
      output = ''
      res = {}
      types.each_key { |k| res[k] = changes.get(k) }
      res.each do |k, v|
        next if v.empty?

        output += "#### #{CL_STRINGS[k][:title]}\n\n"
        output += "- #{v.join("\n- ")}\n\n"
      end
      header_method.call(options[:format]) + output
    end
  end

  def self.format_header(build, fmt)
    case fmt
    when :marked
      "Marked #{build}\n-------------------------\n\n"
    when :def_list
      "#{build}\n"
    when :git
      "#{build}\n\n"
    when :bunch
      "{% available #{build} %}\n\n---\n\n#{build}"
    when :keepachangelog
      "## [#{build}] - #{Time.now.strftime('%F')}\n\n"
    else
      "### #{build}\n\n#{Time.now.strftime('%F %R')}\n\n"
    end
  end

  def self.header(fmt = :markdown, options = {}, version = nil, app_title = nil)
    return '' if options[:no_version]

    version_info = VersionDetector.detect(options, version, app_title, fmt)
    # Do not mutate version/app_title here, just return header_out
    version_info[:header_out]
  end
end

# Version detection module
module VersionDetector
  def self.detect(options, current_version, current_app_name, fmt)
    version = options[:version] || current_version
    app_name = current_app_name
    header_out = ''
    # Rust project detection (applies to all formats)
    if File.exist?('Cargo.toml')
      cargo = IO.read('Cargo.toml')
      app_name = ::Regexp.last_match(1) if cargo =~ /^name\s*=\s*"([^"]+)"/m
      version = ::Regexp.last_match(1) if cargo =~ /^version\s*=\s*"([^"]+)"/m
    elsif Dir.glob('**/*.rs').any?
      rs_files = Dir.glob('**/*.rs')
      rs_files.each do |f|
        content = IO.read(f)
        version = ::Regexp.last_match(1) if !version && content =~ /const VERSION: *&str *= *"([^"]+)"/
        app_name = ::Regexp.last_match(1) if !app_name && content =~ /Command::new\("([^"]+)"\)/
      end
    end
    # Fallbacks
    version ||= if Dir.glob('lib/**/version.rb').length.positive?
                  version_file = Dir.glob('lib/*/version.rb')[0]
                  if version_file
                    begin
                      IO.read(version_file).match(/VERSION *= *(['"])(.*?)\1/)[2]
                    rescue StandardError
                      nil
                    end
                  end
                elsif %w[VERSION VERSION.txt VERSION.md].any? { |f| File.exist?(f) }
                  version_file = %w[VERSION VERSION.txt VERSION.md].find { |f| File.exist?(f) }
                  IO.read(version_file).strip
                elsif `git ver`.strip.length.positive?
                  `git ver`.strip
                end

    if fmt == :keepachangelog
      header_out = ChangelogFormatter.format_header(version, :keepachangelog)
    elsif options[:version]
      header_out = ChangelogFormatter.format_header(options[:version], fmt)
    elsif Dir.glob('lib/**/version.rb').length.positive?
      spec = Dir.glob('*.gemspec')[0]
      if spec
        app_name = File.basename(spec, '.gemspec')
        version_file = Dir.glob('lib/*/version.rb')[0]
        if version_file
          build = begin
            IO.read(version_file).match(/VERSION *= *(['"])(.*?)\1/)[2]
          rescue StandardError
            nil
          end
          version = build
          header_out = ChangelogFormatter.format_header(build, fmt)
        end
      end
    elsif Dir.pwd =~ %r{/Code/nvultra}
      app_name = 'nvUltra (mark 2) 1.0.0'
      version = `git ver`
      header_out = "#{app_name} (#{version})\n-------------------------\n\n"
    elsif Dir.pwd =~ %r{/Code/marked}
      parts = `agvtool mvers -terse`.match(%r{"(.*?)\.xcodeproj.*[^/]+?\.plist"=(\d+\.\d+\.\d+)})[1, 2]
      version = parts[1].strip.to_s
      build = `agvtool vers -terse`.strip
      version += " (#{build})"
      header_out = "Marked #{version}\n-------------------------\n\n"
    elsif Dir.pwd =~ %r{/Code/popclipextensions}
      app_name = 'Brett\'s PopClip Extensions'
      version = `git semnext`
      header_out = ChangelogFormatter.format_header(version, fmt)
    elsif Dir.pwd =~ %r{/Code/niftymenu}
      app_name = 'NiftyMenu'
      version = `git semnext`
      header_out = ChangelogFormatter.format_header(version, fmt)
    elsif %i[def_list bunch].include?(fmt)
      parts = `agvtool mvers -terse`.match(%r{"(.*?)\.xcodeproj.*[^/]+?\.plist"=(\d+\.\d+\.\d+)})[1, 2]
      version = parts[1].strip.to_s
      build = `agvtool vers -terse`.strip
      version += " (#{build})"
      header_out = fmt == :bunch ? "{% available #{build} %}\n\n#{version}" : version
    elsif File.exist?('Package.swift')
      content = IO.read('Package.swift')
      app_name = content.match(/Package\(.*?name: *"(.*?)"/m)[1]
      version = `git semnext`
      header_out = "## #{version}\n\n"
    elsif Dir.glob('**/*-plugin.php').length.positive?
      spec = Dir.glob('**/*-plugin.php')[0]
      if spec
        app_name = File.dirname(spec)
        plugin_files = Dir.glob('**/*-plugin.php')
        plugin_files.filter! { |f| f !~ /test/ }
        version_file = plugin_files[0]
        if version_file
          build = begin
            IO.read(version_file).match(/\* Version: (.*?)\s*$/)[1]
          rescue StandardError
            nil
          end
          version = build
          header_out = ChangelogFormatter.format_header(build, fmt)
        end
      end
    elsif `ag --depth 0 'VERSION *='`.strip.length.positive?
      build = nil
      Dir.glob('*').each do |f|
        next unless `file "#{f}"` =~ /ruby/i

        content = IO.read(f)
        if content =~ /VERSION *= *['"]([\d.]+(\w+)?) ["']/
          build = Regexp.last_match(1)
          break
        end
      end
      if build
        version = build
        header_out = ChangelogFormatter.format_header(build, fmt)
      end
    elsif %w[VERSION VERSION.txt VERSION.md].any? { |f| File.exist?(f) }
      version_file = %w[VERSION VERSION.txt VERSION.md].find { |f| File.exist?(f) }
      app_name = File.basename(File.expand_path('.'))
      version = IO.read(version_file).strip
      header_out = ChangelogFormatter.format_header(version, fmt)
    elsif `git ver`.strip.length.positive?
      version = `git ver`
    else
      unless version
        %w[config.yml config.yaml].each do |filename|
          next unless File.exist?(filename)

          config = YAML.load_file(filename)
          app_name = config.key?('title') ? config['title'] : File.basename(File.dirname(File.expand_path(filename)))
          version = config['version']
          header = "#{app_name} #{version}"
          header_out = "### #{header}\n\n"
        end
      end
      unless version
        begin
          parts = `agvtool mvers -terse`.match(%r{"(.*?)\.xcodeproj.*[^/]+?\.plist"=(\d+\.\d+\.\d+)})[1, 2]
        rescue NoMethodError
          parts = nil
        end
        if parts
          app_name ||= parts[0].strip
          app_name.sub!(/^(notnvalt|nvultra)$/i, 'nvUltra')
          version = parts[1].strip
          header_out = "#{app_name} #{version}"
          build = `agvtool vers -terse`.strip
          version += " (#{build})"
          header_out += %{ (#{build})\n-------------------------\n\n}
        else
          if File.exist?('Rakefile')
            rake_ver = `rake -T 2>/dev/null | grep ver`
            unless rake_ver.empty?
              out = `rake ver 2>/dev/null`.strip
              lines = out.split("\n")
              lines.reject! { |l| l =~ /^(git|change)/i }
              version_line = lines.size == 1 ? lines[0] : lines.find { |l| l =~ /\d+\.\d+\.\d+/ }
              if version_line && version_line =~ /(\d+\.\d+\.\d+\S*)/
                version = Regexp.last_match(1)
                header_out = ChangelogFormatter.format_header(version, fmt)
              end
            end
          end
          if !version && File.exist?('Makefile')
            make_targets = `make -qp 2>/dev/null | grep -E '^(version|ver):'`
            target = if make_targets =~ /^version:/
                       'version'
                     elsif make_targets =~ /^ver:/
                       'ver'
                     end
            if target
              out = `make #{target} 2>/dev/null`.strip
              if out =~ /(\d+\.\d+\.\d+\S*)/
                version = Regexp.last_match(1)
                header_out = ChangelogFormatter.format_header(version, fmt)
              end
            end
          end
          unless version
            repo_name = File.basename(Dir.pwd)
            bin_dirs = %w[bin build]
            bin_path = nil
            bin_dirs.each do |dir|
              next unless Dir.exist?(dir)

              bins = Dir.entries(dir).reject { |f| f =~ /^\./ || File.directory?(File.join(dir, f)) }
              bin_file = bins.find { |b| b == repo_name } || bins.first
              if bin_file
                bin_path = File.join(dir, bin_file)
                break
              end
            end
            if bin_path && File.executable?(bin_path)
              out = `"#{bin_path}" --version 2>/dev/null`.strip
              if out =~ /(\d+\.\d+\.\d+\S*)/
                version = Regexp.last_match(1)
                header_out = ChangeLogger.new(nil, options: options).send(:format_header, version, fmt)
              end
            end
          end
          if !version && system('command -v git-ver >/dev/null 2>&1')
            out = `git ver 2>/dev/null`.strip
            if out =~ /(\d+\.\d+\.\d+\S*)/
              version = Regexp.last_match(1)
              header_out = ChangelogFormatter.format_header(version, fmt)
            end
          end
        end
      end
    end
    { version: version, app_name: app_name, header_out: header_out }
  end
end

# Git log parsing module
module GitLogParser
  # Sort changes for a ChangeLogger instance
  def self.sort_changes(logger)
    chgs = []
    gen_rx = GitLogParser.gen_rx
    logger.instance_variable_get(:@log).changes.each do |l|
      chgs.concat(l.split("\n").delete_if { |ch| ch !~ /#{gen_rx}/ })
    end
    chgs.each do |change|
      CL_STRINGS.each do |k, v|
        logger.changes.add(k, change.clean_entry) if change =~ /(?:@#{v[:rx].downcase}:?|- #{v[:rx]}:)/
      end
    end
  end

  # Sort changes and group by version tags for a ChangeLogger instance
  def self.sort_changes_by_version(logger)
    options = logger.instance_variable_get(:@options)
    tags = GitLogParser.tags_in_range(options)

    if tags.empty?
      # Fall back to regular sorting if no tags found
      sort_changes(logger)
      return
    end

    # Add HEAD as the first entry for unreleased changes
    current_version = logger.version || 'Unreleased'

    # Process each version
    options = logger.instance_variable_get(:@options)
    previous_ref = options[:_cached_revision] || ChangeLogger.revision(options)
    gen_rx = GitLogParser.gen_rx
    tags.reverse.each do |tag_info|
      tag = tag_info[:tag]
      tag_hash = tag_info[:hash]

      entries = GitLogParser.commits_between(previous_ref, tag_hash)
      unless entries.empty?
        version_set = ChangeSet.new
        entries.each do |entry|
          next unless entry.changes

          entry.changes.split("\n").each do |line|
            next if line !~ /#{gen_rx}/

            CL_STRINGS.each do |k, v|
              version_set.add(k, line.clean_entry) if line =~ /(?:@#{v[:rx].downcase}:?|- #{v[:rx]}:)/
            end
          end
        end
        logger.version_changes[tag] = version_set unless GitLogParser.version_set_empty?(version_set)
      end
      previous_ref = tag_hash
    end

    # Get any commits after the last tag (unreleased)
    entries = GitLogParser.commits_between(previous_ref, 'HEAD')
    return if entries.empty?

    version_set = ChangeSet.new
    entries.each do |entry|
      next unless entry.changes

      entry.changes.split("\n").each do |line|
        next if line !~ /#{gen_rx}/

        CL_STRINGS.each do |k, v|
          version_set.add(k, line.clean_entry) if line =~ /(?:@#{v[:rx].downcase}:?|- #{v[:rx]}:)/
        end
      end
    end
    logger.version_changes[current_version] = version_set unless GitLogParser.version_set_empty?(version_set)
  end

  def self.gitlog(options, revision_method, gen_rx_method)
    parse(options, revision_method, gen_rx_method)
  end

  def self.parse(options, revision_method, gen_rx_method)
    since = `git show -s --format=%ad #{revision_method.call}`
    log = `git log --pretty=format:'===%h%n%ci%n%s%n%b' --reverse --since="#{since}"`.strip

    if options[:file]
      content = IO.read(File.expand_path(options[:file])).strip
      log = [
        '===XXXXXXX',
        Time.now.strftime('+%F %T %z'),
        content,
        "\n",
        log
      ].join("\n")
    end

    if log && !log.empty?
      cl = ChangeLog.new
      log.split(/^===/).each do |entry|
        e = split_gitlog(entry.strip, gen_rx_method.call)
        cl.push(e) if e&.githash
      end
      return cl
    else
      warn 'No new entries'
      Process.exit 1
    end

    raise 'Error reading log items'
  end

  def self.gen_rx
    format('(%<b>s)', b: CL_STRINGS.map { |_, v| "(?:@#{v[:rx].downcase}:?|- #{v[:rx]}:)" }.join('|'))
  end

  def self.split_gitlog(entry, gen_rx)
    # Joins entry lines that got wrapped
    lines = entry.strip_non_ascii.gsub(/^((.*?)(?:@|- )#{gen_rx}:?[\s\S]*?)(?=\n\2|\n{2,}|\Z)/s) do |m|
      m.gsub(/\n/, ' ')
    end.split(/\n/)
    loghash = lines.shift
    date = lines.shift
    return nil if lines[0] =~ /^Merge (branch|tag)/

    changes = lines.delete_if { |l| l.strip.empty? }.join("\n")
    Change.new(loghash, date, changes)
  end

  def sort_changes
    chgs = []
    gen_rx = GitLogParser.gen_rx
    @log.changes.each do |l|
      chgs.concat(l.split("\n").delete_if { |ch| ch !~ /#{gen_rx}/ })
    end
    chgs.each do |change|
      CL_STRINGS.each do |k, v|
        @changes.add(k, change.clean_entry) if change =~ /(?:@#{v[:rx].downcase}:?|- #{v[:rx]}:)/
      end
    end
  end

  # Get all tags between the selected revision and HEAD, sorted by commit date
  def self.tags_in_range(options)
    since_hash = options[:_cached_revision] || ChangeLogger.revision(options)
    # Get all tags with their commit dates, newest first
    tag_info = `git tag --sort=-creatordate --format='%(refname:short) %(objectname:short)'`.strip
    return [] if tag_info.empty?

    tags = []
    tag_info.split("\n").each do |line|
      tag, hash = line.split(' ')
      # Check if this tag is after our since revision
      # Use system() to get the exit status properly
      is_ancestor = system("git merge-base --is-ancestor #{since_hash} #{hash} 2>/dev/null")
      tags << { tag: tag, hash: hash } if is_ancestor
    end
    tags
  end

  # Get commits between two refs
  def self.commits_between(from_ref, to_ref)
    log = `git log --pretty=format:'===%h%n%ci%n%s%n%b' --reverse #{from_ref}..#{to_ref}`.strip
    return [] if log.empty?

    entries = []
    gen_rx = GitLogParser.gen_rx
    log.split(/^===/).each do |entry|
      e = GitLogParser.split_gitlog(entry.strip, gen_rx)
      entries << e if e&.githash
    end
    entries
  end

  # Check if a ChangeSet has any entries
  def self.version_set_empty?(changeset)
    CL_STRINGS.keys.all? { |k| changeset.get(k).empty? }
  end
end

# Main class
class App
  LOG_FORMATS = %i[def_list bunch markdown keepachangelog].freeze

  def initialize(args)
    top = `git rev-parse --show-toplevel`.strip
    Dir.chdir(top)

    options = {
      select: false,
      split: false,
      file: nil,
      format: nil,
      copy: false,
      update: nil,
      version: nil,
      no_version: false,
      types: %i[changed new improved fixed],
      order: :desc
    }

    optparse = OptionParser.new do |opts|
      opts.on('--since-version [VER]', 'Show changelog since tag matching VER (full or partial version)') do |ver|
        options[:since_version] = ver
      end
      opts.on('--sv [VER]', 'Alias for --since-version') do |ver|
        options[:since_version] = ver
      end
      opts.banner = %(Usage: #{File.basename(__FILE__)} [options] [CHANGELOG_FILE] [APP_NAME]
      Gets git log entries since last tag containing #{CL_STRINGS.map { |_, v| v[:title] }.join(', ')})

      opts.on('-c', '--copy', 'Copy results to clipboard') do
        options[:copy] = true
      end

      opts.on('-f', '--format FORMAT', "Output format (#{LOG_FORMATS.map(&:to_s).join('|')})") do |fmt|
        unless fmt =~ /^[dbmk]/
          puts "Invalid format: #{fmt}. Available formats: #{LOG_FORMATS.join(', ')}"
          Process.exit 1
        end

        options[:format] = case fmt
                           when /^d/
                             :def_list
                           when /^b/
                             :bunch
                           when /^k/
                             :keepachangelog
                           when /^m/
                             :markdown
                           end
      end

      opts.on('-o', '--only TYPES', "Only output changes of type (#{CL_STRINGS.keys.join(', ')})") do |arg|
        types = arg.split(/ *, */).map(&:downcase)
        options[:types] = []
        types.each do |t|
          unless t =~ /^[cnfi]/
            puts "Invalid change type: #{fmt}. Available types: #{CL_STRINGS.keys.join(', ')}"
            Process.exit 1
          end

          options[:types].push case t
                               when /^c/
                                 :changed
                               when /^n/
                                 :new
                               when /^i/
                                 :improved
                               when /^f/
                                 :fixed
                               end
        end
      end

      opts.on('--file PATH', 'File to read additional commit messages from (for commit-msg hooks)') do |path|
        options[:file] = path
      end

      opts.on('-s', '--select', 'Choose "since" tag') do
        options[:select] = true
      end

      opts.on('--split', 'Split output by version (use with --select)') do
        options[:split] = true
      end
      opts.on('--order ORDER', 'Order of split output: asc (oldest first) or desc (newest first, default)') do |order|
        options[:order] = case order.to_s.downcase
                          when /^a/
                            :asc
                          else
                            :desc
                          end
      end

      opts.on('-u', '--update [FILE]', 'Update changelog file') do |file|
        raise 'Can\'t skip version check when updating changelog file' if options[:no_version]

        if file
          if File.exist?(File.expand_path(file))
            options[:update] = File.expand_path(file)
          else
            args.unshift(file)
          end
        else
          options[:update] = find_changelog
        end
      end

      opts.on('-v', '--version=VER', 'Force version (skips version detection)') do |ver|
        raise 'Invalid version string' unless ver && ver =~ /\d+\.\d+(\.\d+)?(\w+)?( *\([.\d]+\))?/

        options[:version] = ver
      end

      opts.on('-n', '--no_version', 'Skip version check (prevents header output)') do
        raise 'Can\'t skip version check when updating changelog file' if options[:update]

        options[:no_version] = true
      end

      opts.on('-h', '--help', 'Display this screen') do
        puts opts
        exit
      end
    end

    optparse.parse!

    if options[:format].nil?
      file = if options[:update] && File.exist?(options[:update])
               options[:update]
             else
               find_changelog
             end

      if file
        fmt = detect_changelog_type(file)
        options[:format] = fmt.to_sym
        warn "Parsed #{file}, detected format: #{fmt}"
      end
    end

    apptitle = nil

    apptitle = args[0] if args.length

    # If --split is used without --select or --since-version, ignore split and warn
    if options[:split] && !options[:select] && !options[:since_version]
      warn '--split cannot be used without --select or --since-version, ignoring'
      options[:split] = false
    end

    cl = ChangeLogger.new(apptitle, options: options)

    if options[:copy]
      `echo #{Shellwords.escape(cl.to_s)}|pbcopy`
      warn 'Changelog in clipboard'
    elsif options[:update]
      update_changelog(options[:update], cl.to_s, cl.version)
    else
      $stdout.puts cl.to_s
    end
  end

  def update_changelog(file, changes, version)
    # Defensive: ensure @options is always a Hash
    @options ||= {}
    git_ver = `git ver`.strip
    if git_ver.gsub(/[^0-9.]/, '') == version.gsub(/[^0-9.]/, '')
      raise 'Git version matches new version, bump project before running'
    end

    fmt = detect_changelog_type(file)
    input = IO.read(file)
    version_rx = version.gsub(/\./, '\\\.')

    # Detect version order in file (asc/desc)
    order = @options[:order] if @options.is_a?(Hash)
    version_headers = []
    case fmt
    when :keepachangelog
      input.scan(/^## \[(\d+\.\d+\.\d+.*?)\]/) { |m| version_headers << m[0] }
    when :markdown
      input.scan(/^##+ +(\d+\.\d+\.\d+)/) { |m| version_headers << m[0] }
    when :def_list
      input.scan(/^(\d+\.\d+\.\d+)/) { |m| version_headers << m[0] }
    when :bunch
      input.scan(/^\{% available (\d+\.\d+\.\d+)/) { |m| version_headers << m[0] }
    end
    if (order.nil? || order == '') && version_headers.size > 1
      # Compare first two version numbers
      order = Gem::Version.new(version_headers[0]) > Gem::Version.new(version_headers[1]) ? :desc : :asc
    end
    order ||= :desc

    # Check for existing version record (order-aware)
    found_existing = false
    if fmt == :keepachangelog
      if input =~ /^## \[#{version_rx}\]( - \d{4}-\d{2}-\d{2})? *$/m
        warn 'Found existing version record (keepachangelog format)'
        input.sub!(
          /(?mi)(?<=\n|\A)## \[#{version_rx}\]( - \d{4}-\d{2}-\d{2})? *.*?\n+(?=(## \[\d+\.\d+|\[\d+\.\d+.*?\]:))/, changes
        )
        found_existing = true
      end
    elsif input =~ /^(#+ ?)?#{version_rx} *$/
      warn 'Found existing version record'
      input.sub!(/(?mi)(?<=\n|\A)(#+ ?)?#{version_rx} *.*?\n+(?=(#* *\d+\.\d+\.\d+|---))/, changes)
      found_existing = true
    elsif input =~ /^(#+ ?)(.*?) #{version_rx} *$/
      warn 'Found existing version record'
      input.sub!(/(?mi)(?<=\n|\A)(#+ ?)?(.*?) #{version_rx} *.*?\n+(?=(#* *\1 \d+\.\d+\.\d+|---))/, changes)
      found_existing = true
    end

    unless found_existing
      case fmt
      when :keepachangelog
        # Insert at top or bottom based on order
        if order == :desc
          # Insert at top (after any header)
          if input =~ /^## \[\d+\.\d+/m
            input.sub!(/^(## \[\d+\.\d+)/m, "#{changes.strip}\n\n\\1")
          else
            input = "#{changes.strip}\n\n#{input}"
          end
        elsif input =~ /^(\[\d+\.\d+.*?\]:)/m
          # Insert at bottom (before footer links if present)
          input.sub!(/^(\[\d+\.\d+.*?\]:)/m, "#{changes.strip}\n\n\\1")
        else
          input = "#{input.strip}\n\n#{changes.strip}"
        end
        input = add_keepachangelog_link(input, version)
      when :bunch
        warn 'Updating Bunch changelog'
        if order == :desc
          input.sub!(/{% docdiff %}/, "{% docdiff %}\n\n---\n\n#{changes.strip}\n")
        else
          input = "#{input.strip}\n\n---\n\n#{changes.strip}\n"
        end
      when :def_list
        if order == :desc
          input.sub!(/^(\d+\.\d+\.\d+.*?\n+:)/, "#{changes.strip}\n\n\\1")
        else
          input = "#{input.strip}\n\n#{changes.strip}"
        end
      else
        input = if order == :desc
                  "#{changes.strip}\n\n#{input}"
                else
                  "#{input.strip}\n\n#{changes.strip}"
                end
      end
    end
    File.open(file, 'w') { |f| f.puts input }
  end

  # Searches for a file named 'changelog' in the current
  # directory. It returns the first file it finds that
  # matches the pattern, or nil if no files are found. It
  # ignores any files that are executable.
  #
  # @return     [String] First matching file
  #
  def find_changelog
    files = Dir.glob('changelog*')
    files.delete_if { |f| File.executable?(f) }

    files.count.positive? ? files.first : nil
  end

  ##
  ## Takes in a file as an argument and returns a symbol
  ## representing the type of changelog the file contains.
  ## It does this by reading the file and checking for
  ## certain patterns that indicate the type of changelog.
  ## If the file contains a pattern that matches the
  ## markdown format, it will return :markdown. If the file
  ## contains a pattern that matches the bunch format, it
  ## will return :bunch. If the file contains a pattern that
  ## matches the definition list format, it will return
  ## :def_list. If the file does not contain any of these
  ## patterns, it will return :standard.
  ##
  ## @param      file  [String]  The file
  ##
  def detect_changelog_type(file)
    content = IO.read(File.expand_path(file)).strip
    case content
    when /^\#{2,} \[\d+\.\d+/
      :keepachangelog
    when /^\#{2,} \d+\.\d+/
      :markdown
    when /\{% icon (new|fix|imp) %\}/
      :bunch
    when /\d+\.\d+\.\d+(.*?)[\n\s]+:/
      :def_list
    else
      :markdown
    end
  end
end

App.new(ARGV)
